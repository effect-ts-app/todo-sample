# Creating a Usecase

Below is a sample implementation for Creating a Task.
We're taking an iterative approach, where we define the Request and Response classes with the handler at first.

## Tips

- Use the [Model code snippets](../.vscode/model.code-snippets)

## API

1. Create a file under [apps/api/Tasks](../apps/api/Tasks)/Create.ts
2. Create a `Request` class:
```ts
export default class Create extends Post("/tasks")<Create>()({
  listId: prop(TaskListIdU),
  title: prop(nonEmptyString),
  isFavorite: prop(bool),
  myDay: prop(nullable(date)),
}) {}
```
3. Create a `Response` class, if the Response is something else than `void`:
```ts
export class Response extends Model<Response>()({ id: prop(TaskId) }) {}
```
4. Create the Handler (omit `Response` if you didn't create one)
```ts
export default handle({ Request, Response })(
// (Request) => T.Effect<Has<UserProfile> & Has<TodoContext.TodoContext>, NotFoundError | UnauthorizedError | NotLoggedInError, Response>
({ myDay, ..._ }) =>
  T.gen(function* ($) {
    const { Lists, Tasks, Users } = yield* $(TodoContext.TodoContext)

    const user = yield* $(TodoContext.getLoggedInUser)

    if (_.listId !== "inbox") {
      const list = yield* $(Lists.getList(_.listId))
      yield* $(TaskListAuth.access_(list, user.id, identity))
    }

    const task = User.createTask_(user, _)
    yield* $(Tasks.add(task))
    yield* $(
      pipe(
        EO.fromOption(myDay),
        EO.chainEffect((date) => Users.update(user.id, User.addToMyDay(task, date)))
      )
    )

    return { id: task.id }
  })
)
```
5. Add to [routes.ts](../apps/api/Tasks/routes.ts) routes tuple: `R.match(Create, demandLoggedIn)`
from `import Create from "./Create"`

Test api and enjoy. Find autogenerated [openapi.json](https://github.com/patroza/effect-ts-demo-todo/blob/master/apps/api/openapi.json)
or visit the local [swagger](http://localhost:3330/swagger)

## Update Client for Frontend

1. Move `Request` and `Response` to [packages/client/Tasks](../packages/client/Tasks)/Create.ts
2. Export in [_index.ts](../packages/client/Tasks/_index.ts): `export * as Create from "./Create"`
3. Update the handler in api: `export default handle(Tasks.Create)`

## Consume in Frontend

1. Add the `create` to the `export const {` in [client/Tasks/index.ts](../packages/client/Tasks/index.ts)

2. Use
```ts
// (req: Tasks.Create.CreateTask) => T.Effect<Has<TodoClient.ApiConfig> & Has<Http>, FetchError | ResponseError, Tasks.CreateTask.Response>
TodoClient.Tasks.create
```
e.g:
```ts
const { runWithErrorLog } = useServiceContext()
TodoClient.Tasks.create(input)
    ["|>"](runWithErrorLog)
```
\
**Note**: if there is no input required, the signature is just an Effect:
```ts
// T.Effect<Has<TodoClient.ApiConfig> & Has<Http>, FetchError | ResponseError, TodoClient.Tasks.All.Response>
TodoClient.Tasks.all
```
which would be used so:
```ts
const { runWithErrorLog } = useServiceContext()
TodoClient.Tasks.all
    ["|>"](runWithErrorLog)
```
