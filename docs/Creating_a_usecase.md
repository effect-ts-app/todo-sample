# Creating a Usecase

Below is a sample implementation for Creating a Task.
We're taking an iterative approach, where we define the Request and Response classes with the handler at first.

## API

1. Create a file under `apps/api/Tasks`
2. Create a `Request` class: `WriteRequest` or `ReadRequest`
```ts
export class Request extends S.WriteRequest<Request>()("POST", "/tasks", {
  body: S.props({
    listId: S.prop(TaskListIdU),
    title: S.prop(S.nonEmptyString),
    isFavorite: S.prop(S.bool),
    myDay: S.prop(S.nullable(S.date)),
  }),
}) {}
```
3. Create a `Response` class, if the Response is something else than `void`:
```ts
export class Response extends S.Model<Response>()(S.props({ id: S.prop(TaskId) })) {}
```
4. Create the Handler (omit `Response` if you didn't create one)
```ts
export default handle({ Request, Response })(
// (Request) => T.Effect<Has<UserEnv> & Has<TaskContext.TaskContext>, NotFoundError | UnauthorizedError | NotLoggedInError, Response>
({ myDay, ..._ }) =>
  T.gen(function* ($) {
    const user = yield* $(getLoggedInUser)

    if (_.listId !== "inbox") {
      const list = yield* $(TaskContext.getTaskList(_.listId))
      yield* $(authorizeTaskList.authorize_(list, user.id, identity))
    }

    const task = User.createTask_(user, _)
    yield* $(TaskContext.add(task))
    yield* $(
      pipe(
        EO.fromOption(myDay),
        EO.chainEffect((date) =>
          TaskContext.updateUser(user.id, User.addToMyDay(task, date))
        )
      )
    )

    return { id: task.id }
  })
)
```
5. Add to `routes.ts` routes tuple: `R.matchA(CreateTask, demandLoggedIn)`
from `import CreateTask from "./CreateTask"`

Test api and enjoy. Find autogenerated [openapi.json](https://github.com/patroza/effect-ts-demo-todo/blob/master/apps/api/openapi.json)
or visit the local [swagger](http://localhost:3330/swagger)

## Update Client for Frontend

1. Move `Request` and `Response` to `packages/client/Tasks/CreateTask.ts`
2. Export in `_index.ts`: `export * as CreateTask from "./CreateTask"`
3. Update the handler in api: `export default handle(Tasks.CreateTask)`

## Consume in Frontend

1. Use
```ts
// (req: TodoClient.Tasks.CreateTask.Request) => T.Effect<Has<TodoClient.ApiConfig> & Has<Http>, FetchError | ResponseError, TodoClient.Tasks.CreateTask.Response>
TodoClient.TasksClient.CreateTask
```
e.g:
```ts
const { runWithErrorLog } = useServiceContext()
TodoClient.TasksClient.CreateTask({...data})
    ["|>"](runWithErrorLog)
```
\
**Note**: if there is no input required, the signature is just an Effect:
```ts
// T.Effect<Has<TodoClient.ApiConfig> & Has<Http>, FetchError | ResponseError, TodoClient.Tasks.GetTasks.Response>
TodoClient.TasksClient.GetTasks
```
which would be used so:
```ts
const { runWithErrorLog } = useServiceContext()
TodoClient.TasksClient.GetTasks
    ["|>"](runWithErrorLog)
```
